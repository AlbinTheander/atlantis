/**
 * This task will trigger a new major release. An exception will be thrown if the desired version
 * name segment or the version code couldn't be incremented properly. This task will trigger the
 * production environment to perform the actual release. Local releases can only be performed
 * manually for now.
 *
 * The flow for triggering the release is as follows:
 *
 * 1. Get the version name and version code from the latest tag's subject line.
 * 2. Split the version name into ${major}.${minor}.${patch} segments.
 * 3. Increase the ${major} segment and the version code by one.
 * 4. Create a new annotated tag and push it to the remote repository.
 */
task prepareMajorRelease {
    def oldVersionName = getVersionFromLatestTag()
    def segments = oldVersionName.tokenize('.')
    def newVersionName = [segments[0].toInteger() + 1, 0, 0].join('.')
    createNewTag(oldVersionName, newVersionName)
}

/**
 * This task will trigger a new minor release. An exception will be thrown if the desired version
 * name segment or the version code couldn't be incremented properly. This task will trigger the
 * production environment to perform the actual release. Local releases can only be performed
 * manually for now.
 *
 * The flow for triggering the release is as follows:
 *
 * 1. Get the version name and version code from the latest tag's subject line.
 * 2. Split the version name into ${major}.${minor}.${patch} segments.
 * 3. Increase the ${minor} segment and the version code by one.
 * 4. Create a new annotated tag and push it to the remote repository.
 */
task prepareMinorRelease {
    def oldVersionName = getVersionFromLatestTag()
    def (major, minor) = oldVersionName.tokenize('.')
    def newVersionName = [major, minor.toInteger() + 1, 0].join('.')
    createNewTag(oldVersionName, newVersionName)
}

/**
 * This task will trigger a new patch release. An exception will be thrown if the desired version
 * name segment or the version code couldn't be incremented properly. This task will trigger the
 * production environment to perform the actual release. Local releases can only be performed
 * manually for now.
 *
 * The flow for triggering the release is as follows:
 *
 * 1. Get the version name and version code from the latest tag's subject line.
 * 2. Split the version name into ${major}.${minor}.${patch} segments.
 * 3. Increase the ${patch} segment and the version code by one.
 * 4. Create a new annotated tag and push it to the remote repository.
 */
task preparePatchRelease {
    def oldVersionName = getVersionFromLatestTag()
    def (major, minor, patch) = oldVersionName.tokenize('.')
    def newVersionName = [major, minor, patch.toInteger() + 1].join('.')
    createNewTag(oldVersionName, newVersionName)
}

/**
 * Prepares the current version name to use for the project. The version name will follow the SEMVER
 * pattern of ${major}.${minor}.${patch}. If this method is called from a non-production environment
 * then "-SNAPSHOT" will be appended to the version name. The parts of the version name will be
 * extracted from the latest release tag in git repository.
 *
 * @return The version name or an empty string
 */
ext.prepareVersionName = {
    def versionName = getVersionFromLatestTag()

    if (!versionName.isEmpty()) {
        versionName = System.getenv('CIRCLECI') ? versionName : "${versionName}-SNAPSHOT"
        println(versionName)
    }

    return versionName
}

/**
 * Fetches all tags from the remote repository and extracts the version name and version code from
 * the latest release tag. If there is a numeric system property set for a build number, then that
 * value will override any version code found in the tag.
 *
 * @return The version notation as a string: "${major}.${minor}.${path} ${versionCode}
 */
private def getVersionFromLatestTag() {
    'git fetch origin \'refs/tags/*:refs/tags/*\''.bash()

    def tag = 'git for-each-ref --count=1 --sort=-taggerdate --format=\'%(tag)\' \'refs/tags/v[0-9]*.[0-9]*.[0-9]*\''.bash()
    def filter = 's/v\\([0-9]\\{1,\\}.[0-9]\\{1,\\}.[0-9]\\{1,\\}\\)/\\1/p'
    def versions = "echo '${tag}' | sed -n '${filter}'".bash().trim()
    if (versions.isEmpty())
        return '0.0.0'

    return versions
}

/**
 * Creates a new annotated version tag.
 *
 * @param oldVersionName Used for collecting all commits pushed since.
 * @param newVersionName Used for creating the new tag.
 */
private def createNewTag(String oldVersionName, String newVersionName) {
    def body = "git log --pretty=format:'* %s' v${oldVersionName}...HEAD".bash()
    "git tag -a v${newVersionName} -m 'Version ${newVersionName}\n\n${body}'".bash()

    println("\n\nSuccessfully created tag: v${newVersionName}")
    println('\nYou can now:')
    println("  1. Show the tag details:     git show v${newVersionName}")
    println("  2. Edit the tag message:     git tag -a -f v${newVersionName}")
    println("  3. Delete the new tag:       git tag -d v${newVersionName}")
    println('  4. Push the tag to remote:   git push --tags')
}

/**
 * Adds the "bash()" method to all strings. The method will allow for evaluating the string in the
 * bash shell and returns any produced output. If the process doesn't terminate in 10 seconds, then
 * the evaluation is aborted and an empty string is returned.
 *
 * @return The output of the evaluation or an empty string.
 */
String.metaClass.bash = { ->
    ProcessBuilder processBuilder = new ProcessBuilder('bash', '-c', delegate)
    processBuilder.redirectErrorStream(true)

    Process process = processBuilder.start()
    process.getOutputStream().close()

    try {
        process.waitForOrKill(10_000)
        def output = process.text
        return output ? output : ''
    } catch (IOException | InterruptedException ignore) {
        return ''
    }
}
