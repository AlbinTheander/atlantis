/**
 * This task will prepare the current VERSION_NAME and VERSION_CODE to use for the project. The
 * VERSION_NAME will follow the SEMVER pattern of ${major}.${minor}.${patch}. If this task isn't
 * issued from the production environment, then "-SNAPSHOT" will be appended to the version name.
 * The parts of the version name will be extracted from the latest release tag in git repository.
 * This task will try to fetch any tags from the remote repository first.
 *
 * The flow of this task is:
 *
 * 1. Get the version name and version code from the latest tag's subject line.
 * 2. If this isn't the production environment, add "-SNAPSHOT" to the version name.
 * 3. Store the version name in the "VERSION_NAME" system property.
 * 4. Store the version code in the "VERSION_CODE" system property.
 */
task prepareVersion << {
    def (versionName, versionCode) = getVersionFromLatestTag().tokenize()
    println("Prepared version: ${versionName} (${versionCode})")

    if (!versionName.isEmpty())
        System.setProperty('VERSION_NAME', System.hasProperty('CIRCLECI') ? versionName : "${versionName}-SNAPSHOT")

    if (versionCode.isInteger())
        System.setProperty('VERSION_CODE', versionCode)
}

/**
 * This task will trigger a new major release. An exception will be thrown if the desired version
 * name segment or the version code couldn't be incremented properly. This task will trigger the
 * production environment to perform the actual release. Local releases can only be performed
 * manually for now.
 *
 * The flow for triggering the release is as follows:
 *
 * 1. Get the version name and version code from the latest tag's subject line.
 * 2. Split the version name into ${major}.${minor}.${patch} segments.
 * 3. Increase the ${major} segment and the version code by one.
 * 4. Create a new annotated tag and push it to the remote repository.
 */
task prepareMajorRelease << {
    def oldVersionName = getVersionFromLatestTag()
    def (major, minor, patch) = oldVersionName.tokenize('.')
    def newVersionName = [major.toInteger() + 1, minor, patch].join('.')
    createNewTag(oldVersionName, newVersionName)
}

/**
 * This task will trigger a new minor release. An exception will be thrown if the desired version
 * name segment or the version code couldn't be incremented properly. This task will trigger the
 * production environment to perform the actual release. Local releases can only be performed
 * manually for now.
 *
 * The flow for triggering the release is as follows:
 *
 * 1. Get the version name and version code from the latest tag's subject line.
 * 2. Split the version name into ${major}.${minor}.${patch} segments.
 * 3. Increase the ${minor} segment and the version code by one.
 * 4. Create a new annotated tag and push it to the remote repository.
 */
task prepareMinorRelease << {
    def oldVersionName = getVersionFromLatestTag()
    def (major, minor, patch) = oldVersionName.tokenize('.')
    def newVersionName = [major, minor.toInteger() + 1, patch].join('.')
    createNewTag(oldVersionName, newVersionName)
}

/**
 * This task will trigger a new patch release. An exception will be thrown if the desired version
 * name segment or the version code couldn't be incremented properly. This task will trigger the
 * production environment to perform the actual release. Local releases can only be performed
 * manually for now.
 *
 * The flow for triggering the release is as follows:
 *
 * 1. Get the version name and version code from the latest tag's subject line.
 * 2. Split the version name into ${major}.${minor}.${patch} segments.
 * 3. Increase the ${patch} segment and the version code by one.
 * 4. Create a new annotated tag and push it to the remote repository.
 */
task preparePatchRelease << {
    def oldVersionName = getVersionFromLatestTag()
    def (major, minor, patch) = oldVersionName.tokenize('.')
    def newVersionName = [major, minor, patch.toInteger() + 1].join('.')
    createNewTag(oldVersionName, newVersionName)
}

/**
 * Fetches all tags from the remote repository and extracts the version name and version code from
 * the latest release tag. If there is a numeric system property set for a build number, then that
 * value will override any version code found in the tag.
 *
 * @return The version notation as a string: "${major}.${minor}.${path} ${versionCode}
 */
private def getVersionFromLatestTag() {
    'git fetch origin \'refs/tags/*:refs/tags/*\''.bash()

    def tag = 'git for-each-ref --count=1 --sort=-taggerdate --format=\'%(tag)\' \'refs/tags/v[0-9]*.[0-9]*.[0-9]*\''.bash()
    def filter = 's/v\\([0-9]\\{1,\\}.[0-9]\\{1,\\}.[0-9]\\{1,\\}\\)/\\1/p'
    def versions = "echo '${tag}' | sed -n '${filter}'".bash().trim()
    if (versions.isEmpty())
        throw new IllegalStateException("Couldn't extract version from tag: '${tag}'")

    return versions
}

/**
 * Creates a new annotated version tag.
 *
 * @param oldVersionName Used for collecting all commits pushed since.
 * @param newVersionName Used for creating the new tag.
 */
private def createNewTag(String oldVersionName, String newVersionName) {
    def body = "git log --pretty=format:'* %s' v${oldVersionName}...HEAD".bash()
    "git tag -a v${newVersionName} -m '${body}'".bash()

    println("\n\nSuccessfully created tag: v${newVersionName}")
    println('\nYou can now:')
    println("  1. Show the tag details:     git show v${newVersionName}")
    println("  2. Edit the tag message:     git tag -a -f v${newVersionName}")
    println("  3. Delete the new tag:       git tag -d v${newVersionName}")
    println('  4. Push the tag to remote:   git push --tags')
}

/**
 * Adds the "bash()" method to all strings. The method will allow for evaluating the string in the
 * bash shell and returns any produced output. If the process doesn't terminate in 10 seconds, then
 * the evaluation is aborted and an empty string is returned.
 *
 * @return The output of the evaluation or an empty string.
 */
String.metaClass.bash = { ->
    ProcessBuilder processBuilder = new ProcessBuilder('bash', '-c', delegate)
    processBuilder.redirectErrorStream(true)

    Process process = processBuilder.start()
    process.getOutputStream().close()

    try {
        process.waitForOrKill(10_000)
        def output = process.text
        return output ? output : ''
    } catch (IOException | InterruptedException ignore) {
        return ''
    }
}
